### Содержание

1. [До начала работы](#0-до-начала-работы)
   1. [Установите Flask](#установите-flask)
   2. [Установите Flask-CORS](#установите-flask-cors)
2. [Как в общем выглядит модуль с Flask на Python и как это принимается из React](#1-как-в-общем-выглядит-модуль-с-flask-на-python-и-как-это-принимается-из-react)
3. [Отправка и получение данных (GET)](#2-отправка-и-получение-данных-get)
4. [Отправка данных (POST)](#3-отправка-данных-post)
5. [Как Flask работает внутри](#4-как-flask-работает-внутри)
6. [Как Flask связывается с React](#5-как-flask-связывается-с-react)
7. [Что такое REST API](#6-что-такое-rest-api)
8. [Что такое `fetch` API](#7-что-такое-fetch-api)
9. [Что такое CORS](#8-что-такое-cors)
10. [Стриминг данных при помощи Server-Sent Events (SSE)](#9-стриминг-данных-при-помощи-server-sent-events-sse)
    1. [Ключевые особенности SSE](#ключевые-особенности-sse)
    2. [SSE в Flask (Бэкенд)](#sse-в-flask-бэкенд)
    3. [Пример Flask-бэкенда с SSE](#пример-flask-бэкенда-с-sse)
    4. [SSE в React (Фронтенд)](#sse-в-react-фронтенд)
    5. [Пример React-компонента для получения прогресса по SSE](#пример-react-компонента-для-получения-прогресса-по-sse)
    6. [Общий рабочий процесс для сложной операции](#общий-рабочий-процесс-для-сложной-операции)
    7. [Когда использовать SSE?](#когда-использовать-sse)
    8. [Ограничения и соображения](#ограничения-и-соображения)

### 0. До начала работы

Чтобы установить Flask, выполните следующие шаги:

##### Установите Flask:

`pip install Flask`

Эта команда установит Flask и его основные зависимости (Werkzeug, Jinja2, Click) в вашу виртуальную среду.

##### Установите Flask-CORS:

Для взаимодействия с React-приложением, которое обычно запускается на другом порту или домене, необходимо настроить Cross-Origin Resource Sharing (CORS). Для Flask существует удобное расширение Flask-CORS.

`pip install Flask-CORS`

### 1. Как в общем выглядит модуль с Flask на Python и как это принимается из React

Flask-приложение будет выступать в роли API-сервера, предоставляющего данные React-приложению. React-приложение, в свою очередь, будет отправлять запросы к этому API и отображать полученные данные.

**Пример кода Flask**

```python
from flask import Flask, jsonify, request
from flask_cors import CORS # Импортируем Flask-CORS

app = Flask(__name__)
CORS(app) # Инициализируем CORS для всего приложения. По умолчанию разрешает все источники.

# Простой маршрут для получения данных
@app.route('/api/data', methods=['GET'])
def get_data():
    data = {
        "message": "Привет от Flask!",
        "items": ["Элемент 1", "Элемент 2", "Элемент 3"]
    }
    return jsonify(data) # jsonify автоматически устанавливает Content-Type: application/json

# Маршрут для отправки данных (POST-запрос)
@app.route('/api/submit', methods=['POST'])
def submit_data():
    if request.is_json:
        received_data = request.get_json()
        print(f"Получены данные от React: {received_data}")
        # Здесь можно обработать данные, сохранить в базу и т.д.
        response_message = f"Данные '{received_data.get('name', 'N/A')}' успешно получены!"
        return jsonify({"status": "success", "message": response_message}), 200
    else:
        return jsonify({"status": "error", "message": "Запрос должен быть в формате JSON"}), 400

if __name__ == '__main__':
    # Запуск Flask-приложения в режиме отладки.
    # В продакшене используйте WSGI-сервер (Gunicorn, uWSGI).
    app.run(debug=True, port=5000) # Запускаем на порту 5000.
```

**Пример кода React**

```javascript
import React, { useState, useEffect } from "react";

function App() {
  const [message, setMessage] = useState("");
  const [items, setItems] = useState([]);
  const [inputValue, setInputValue] = useState("");
  const [submitStatus, setSubmitStatus] = useState("");

  // useEffect для выполнения GET-запроса при монтировании компонента
  useEffect(() => {
    // Используем fetch API для получения данных с Flask-бэкенда [18]
    fetch("http://localhost:5000/api/data")
      .then((response) => {
        // Проверяем, что ответ успешный (статус 2xx)
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.json(); // Парсим JSON-ответ
      })
      .then((data) => {
        setMessage(data.message);
        setItems(data.items);
      })
      .catch((error) => {
        console.error("Ошибка при получении данных:", error);
        setMessage("Не удалось загрузить данные.");
      });
  }, []);

  // Функция для отправки данных POST-запросом
  const handleSubmit = async (event) => {
    event.preventDefault(); // Предотвращаем перезагрузку страницы при отправке формы

    try {
      const response = await fetch("http://localhost:5000/api/submit", {
        method: "POST", // Указываем метод POST
        headers: {
          "Content-Type": "application/json", // Обязательно указываем тип контента как JSON
        },
        body: JSON.stringify({ name: inputValue }), // Преобразуем объект в JSON-строку
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();
      setSubmitStatus(data.message);
      setInputValue(""); // Очищаем поле ввода
    } catch (error) {
      console.error("Ошибка при отправке данных:", error);
      setSubmitStatus("Не удалось отправить данные.");
    }
  };

  return (
    <div style={{ padding: "20px", fontFamily: "Arial, sans-serif" }}>
      <h1>Приложение React + Flask</h1>

      <section>
        <h2>Данные с Flask (GET-запрос)</h2>
        <p>{message}</p>
        <ul>
          {items.map((item, index) => (
            <li key={index}>{item}</li>
          ))}
        </ul>
      </section>

      <section style={{ marginTop: "30px" }}>
        <h2>Отправка данных на Flask (POST-запрос)</h2>
        <form onSubmit={handleSubmit}>
          <input
            type="text"
            value={inputValue}
            onChange={(e) => setInputValue(e.target.value)}
            placeholder="Введите что-нибудь..."
            style={{ padding: "8px", marginRight: "10px" }}
          />
          <button
            type="submit"
            style={{ padding: "8px 15px", cursor: "pointer" }}>
            Отправить на Flask
          </button>
        </form>
        <p
          style={{
            marginTop: "10px",
            color: submitStatus.includes("успешно") ? "green" : "red",
          }}>
          {submitStatus}
        </p>
      </section>
    </div>
  );
}

export default App;
```

### 2. Отправка и получение данных (GET)

Взаимодействие начинается с того, что клиентское приложение (React) отправляет HTTP-запрос к серверу (Flask). Для получения данных используется метод `GET`.

На стороне Flask создается маршрут (`@app.route('/api/data', methods=['GET'])`), который при получении `GET`-запроса выполняет определенную функцию. Эта функция формирует данные, обычно в виде словаря Python, и затем преобразует их в формат JSON с помощью `jsonify` из Flask. `jsonify` также устанавливает правильный заголовок `Content-Type: application/json` в ответе, что важно для корректной интерпретации данных на стороне клиента.

На стороне React, в компоненте, используется хук `useEffect` для выполнения запроса при монтировании компонента. Внутри `useEffect` вызывается нативный `fetch` API браузера. `fetch('http://localhost:5000/api/data')` отправляет запрос. Полученный ответ обрабатывается цепочкой `.then()`: сначала проверяется статус ответа (`response.ok`), затем ответ парсится как JSON (`response.json()`). Полученные данные используются для обновления состояния компонента (`setMessage`, `setItems`), что приводит к перерисовке UI и отображению данных, полученных с Flask. Обработка ошибок (`.catch()`) необходима для реакции на проблемы с сетью или сервером.

### 3. Отправка данных (POST)

Для отправки данных с клиента на сервер, например, при заполнении формы, используется метод `POST`.

На стороне React создается форма с полем ввода и кнопкой. При отправке формы (событие `onSubmit`) вызывается асинхронная функция `handleSubmit`. В этой функции `fetch` вызывается с дополнительными параметрами: `method: 'POST'`, `headers: { 'Content-Type': 'application/json' }` и `body: JSON.stringify({ name: inputValue })`. Заголовок `Content-Type: application/json` информирует сервер о том, что тело запроса содержит JSON-данные. `JSON.stringify()` преобразует JavaScript-объект в строку JSON, так как `fetch` ожидает строковое тело запроса.

На стороне Flask, маршрут (`@app.route('/api/submit', methods=['POST'])`) настроен на прием `POST`-запросов. Внутри функции-обработчика используется объект `request` из Flask. `request.is_json` проверяет, был ли запрос отправлен с заголовком `Content-Type: application/json`. Если да, `request.get_json()` автоматически парсит JSON-тело запроса в словарь Python. Полученные данные обрабатываются, и сервер отправляет ответ клиенту, указывая статус операции.

### 4. Как Flask работает внутри

Flask — это микрофреймворк для веб-разработки на Python. Приставка "микро" означает, что он предоставляет только базовые функции для создания веб-приложений, такие как маршрутизация, обработка запросов и ответов, и не включает встроенные решения для баз данных, аутентификации или других сложных задач. Это дает разработчику большую гибкость в выборе инструментов и библиотек.

В основе Flask лежат две ключевые библиотеки:

- **Werkzeug**: это набор инструментов WSGI (Web Server Gateway Interface), который обрабатывает запросы и ответы. WSGI — это стандарт взаимодействия между веб-сервером (например, Gunicorn, Apache с mod_wsgi) и Python-приложением. Он позволяет веб-серверу передавать запросы в Python-приложение и получать ответы.
- **Jinja2**: это мощный и гибкий шаблонизатор, используемый для генерации HTML-страниц на основе данных.

Когда клиент (например, браузер или React-приложение) отправляет HTTP-запрос на сервер, происходит следующий цикл обработки запроса-ответа во Flask:

1. **Клиентский запрос**: Браузер отправляет HTTP-запрос (GET, POST и т.д.) на URL-адрес.
2. **Веб-сервер/WSGI-сервер**: Веб-сервер (например, Nginx) получает запрос и передает его WSGI-серверу (например, Gunicorn), который, в свою очередь, передает его Flask-приложению.
3. **Маршрутизация**: Flask-приложение получает запрос. На основе URL-адреса и HTTP-метода (GET, POST и т.д.) Flask определяет, какая функция-обработчик (так называемая "view function") должна быть вызвана. Это сопоставление URL-адресов с функциями называется маршрутизацией и определяется с помощью декоратора `@app.route()`.
4. **Объект запроса (`request`)**: Flask создает объект `request`, который содержит всю информацию о входящем запросе: HTTP-метод, заголовки, параметры URL, данные формы, JSON-тело и т.д.,
5. **Выполнение функции-обработчика**: Вызывается соответствующая функция-обработчик. Внутри этой функции разработчик получает доступ к данным запроса через объект `request`, выполняет необходимую логику (например, обращение к базе данных, вычисления) и формирует данные для ответа.
6. **Объект ответа (`response`)**: Функция-обработчик возвращает данные, которые Flask преобразует в объект `response`. Это может быть строка HTML, JSON-данные, перенаправление или другой тип ответа. Flask автоматически устанавливает необходимые заголовки HTTP.
7. **Отправка ответа**: Объект `response` отправляется обратно через WSGI-сервер и веб-сервер клиенту.

### 5. Как Flask связывается с React

Flask и React взаимодействуют по принципу клиент-серверной архитектуры, где они выступают как отдельные, независимые компоненты. React отвечает за "фронтенд" (пользовательский интерфейс), а Flask — за "бэкенд" (логику сервера, обработку данных, API).

Связь между ними осуществляется через **API (Application Programming Interface)**, обычно с использованием принципов **REST (Representational State Transfer)**. React-приложение отправляет HTTP-запросы (GET, POST, PUT, DELETE и т.д.) на определенные URL-адреса, предоставляемые Flask-бэкендом. Flask обрабатывает эти запросы, выполняет необходимые операции и отправляет обратно HTTP-ответы, чаще всего содержащие данные в формате JSON.

Этот подход позволяет разрабатывать фронтенд и бэкенд независимо друг от друга, используя разные языки и технологии.

### 6. Что такое REST API

**REST API** (Representational State Transfer Application Programming Interface) — это архитектурный стиль для построения распределенных систем, таких как веб-сервисы. Он не является протоколом, а скорее набором принципов и ограничений, которые определяют, как должна быть организована связь между клиентом и сервером.

Ключевые принципы REST API:

- **Клиент-серверная архитектура**: Четкое разделение между клиентской частью (которая запрашивает ресурсы) и серверной частью (которая предоставляет ресурсы). Это позволяет разрабатывать и масштабировать их независимо.
- **Отсутствие состояния (Stateless)**: Каждый запрос от клиента к серверу должен содержать всю информацию, необходимую для обработки этого запроса. Сервер не хранит никакого состояния клиента между запросами. Это упрощает масштабирование и повышает надежность.
- **Кэшируемость (Cacheable)**: Ответы сервера могут быть помечены как кэшируемые или некэшируемые. Это позволяет клиентам кэшировать данные, что улучшает производительность и снижает нагрузку на сервер.
- **Единообразный интерфейс (Uniform Interface)**: Это центральный принцип REST. Он включает несколько ограничений:
  - **Идентификация ресурсов**: Ресурсы (данные или сервисы) идентифицируются с помощью уникальных URL (Uniform Resource Locators).
  - **Манипуляция ресурсами через представления**: Клиент взаимодействует с ресурсами через их представления (например, JSON или XML).
  - **Самоописывающие сообщения**: Каждое сообщение (запрос или ответ) содержит достаточно информации для его интерпретации.
  - **HATEOAS (Hypermedia As The Engine Of Application State)**: Ресурсы могут содержать ссылки на другие связанные ресурсы, что позволяет клиенту динамически перемещаться по API.
- **Многослойная система (Layered System)**: Клиент может не знать, взаимодействует ли он напрямую с конечным сервером или с посредниками (прокси, балансировщики нагрузки).
- **Код по требованию (Code-On-Demand)** (опционально): Сервер может временно расширять функциональность клиента, передавая исполняемый код (например, JavaScript).

REST API использует стандартные HTTP-методы для выполнения операций с ресурсами:

- `GET`: Получение ресурса или коллекции ресурсов.
- `POST`: Создание нового ресурса.
- `PUT`: Полное обновление существующего ресурса.
- `PATCH`: Частичное обновление существующего ресурса.
- `DELETE`: Удаление ресурса.

### 7. Что такое `fetch` API

`fetch` API — это современный, нативный JavaScript-интерфейс, предоставляемый браузерами, для выполнения сетевых запросов (например, HTTP-запросов) к серверам. Он является более мощной и гибкой заменой устаревшему `XMLHttpRequest` (XHR).

Основные особенности `fetch` API:

- **Основан на промисах (Promises)**: `fetch` возвращает `Promise`, что упрощает работу с асинхронными операциями и позволяет использовать цепочки `.then()` и `.catch()` для обработки успешных ответов и ошибок, а также синтаксис `async/await`.
- **Гибкость**: Позволяет настраивать различные аспекты запроса, такие как HTTP-метод (GET, POST и т.д.), заголовки, тело запроса и режим кэширования.
- **Поддержка различных типов данных**: Может отправлять и получать данные в различных форматах, включая JSON, FormData, Blob и текст.

Пример базового использования `fetch` для GET-запроса:

```javascript
fetch("https://api.example.com/data")
  .then((response) => response.json()) // Парсим ответ как JSON
  .then((data) => console.log(data)) // Обрабатываем полученные данные
  .catch((error) => console.error("Ошибка:", error)); // Обработка ошибок
```

Пример использования `fetch` для POST-запроса с JSON-телом:

```javascript
fetch('https://api.example.com/submit', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({ name: 'Пример' }) // Отправляем JSON-строку
})
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error('Ошибка:', [[16]](https://testdriven.io/blog/how-are-requests-processed-in-flask/) error));
```

### 8. Что такое CORS

**CORS** (Cross-Origin Resource Sharing — совместное использование ресурсов между разными источниками) — это механизм безопасности, реализованный в веб-браузерах, который ограничивает, какие веб-страницы могут запрашивать ресурсы с других доменов, чем тот, с которого была загружена сама страница.

Причина существования CORS — это **политика одного источника (Same-Origin Policy)**. Эта политика безопасности запрещает JavaScript-коду, запущенному на одной веб-странице, делать запросы к ресурсам, расположенным на другом "источнике" (домене, протоколе или порту), если это явно не разрешено. Например, если ваше React-приложение запущено на `http://localhost:3000`, а Flask-бэкенд на `http://localhost:5000`, то без CORS браузер заблокирует запросы от React к Flask, так как они находятся на разных портах (разные источники).

Для того чтобы разрешить кросс-доменные запросы, сервер (в данном случае Flask) должен явно указать, какие источники, методы и заголовки разрешены. Это делается путем добавления специальных HTTP-заголовков в ответы сервера.

Расширение **Flask-CORS** упрощает эту задачу, позволяя легко настроить необходимые заголовки CORS в вашем Flask-приложении. Например, `CORS(app)` в Flask-приложении по умолчанию разрешает запросы со всех источников (`*`) для всех методов, что удобно для разработки. В продакшене рекомендуется явно указывать разрешенные источники для повышения безопасности.

### 9. Стриминг данных при помощи Server-Sent Events (SSE)

**Server-Sent Events (SSE)** — это технология, которая позволяет веб-серверу отправлять автоматические "пуш"-уведомления (потоки событий) клиенту через одно HTTP-соединение. В отличие от WebSockets, SSE является однонаправленной связью (сервер -> клиент), что делает её идеальной для сценариев, где клиенту нужно получать обновления от сервера, но не отправлять много данных в ответ (например, уведомления, ленты новостей, прогресс выполнения задач).

#### Ключевые особенности SSE

**Однонаправленная связь:** Данные идут только от сервера к клиенту.
**Использует HTTP:** Работает поверх стандартного HTTP, что упрощает развертывание и совместимость с существующей сетевой инфраструктурой (прокси, балансировщики нагрузки).
**Автоматическое переподключение:** Браузер автоматически пытается переподключиться, если соединение прерывается.
**Формат данных:** События передаются в простом текстовом формате `text/event-stream`. Каждое событие состоит из полей `data:`, `event:`, `id:` и `retry:`.

#### SSE в Flask (Бэкенд)

Для реализации SSE во Flask, мы будем использовать генератор, который будет отправлять данные клиенту по мере их появления. Flask позволяет обернуть генератор в объект `Response` с соответствующим `mimetype`.

**Основные шаги**

1.  **Импорт необходимых модулей:** `Response` и `stream_with_context` из `flask`.
2.  **Определение маршрута:** Создайте маршрут, который будет служить точкой входа для SSE-соединения.
3.  **Функция-генератор:** Эта функция будет генерировать события. Она должна возвращать строки в формате SSE.
    - Каждое событие должно заканчиваться двумя символами новой строки (`\n\n`).
    - `data:`: Содержимое события.
    - `event:` (опционально): Имя события, позволяет клиенту слушать конкретные типы событий.
    - `id:` (опционально): Уникальный идентификатор события, используется для автоматического переподключения.
    - `retry:` (опционально): Время в миллисекундах, через которое клиент должен попытаться переподключиться.
4.  **Обработка долгой операции:** **Важно!** Сама долгая операция не должна выполняться синхронно в той же функции, которая генерирует SSE. Это заблокирует соединение. Вместо этого, долгая операция должна быть запущена в отдельном потоке, процессе или с помощью очереди задач (Celery, RQ), а SSE-маршрут должен лишь "слушать" её прогресс (например, через Redis Pub/Sub, очередь или общую переменную).

#### Пример Flask-бэкенда с SSE

```python
from flask import Flask, Response, stream_with_context
import time
import threading
import queue # Используем очередь для передачи прогресса из фоновой задачи

app = Flask(__name__)

# Словарь для хранения очередей прогресса для каждой задачи
# В реальном приложении это может быть Redis Pub/Sub или база данных
task_progress_queues = {}

# Имитация долгой операции, которая обновляет прогресс
def long_running_task(task_id):
    if task_id not in task_progress_queues:
        task_progress_queues[task_id] = queue.Queue()

    q = task_progress_queues[task_id]
    for i in range(101):
        time.sleep(0.1) # Имитация работы
        # Отправляем прогресс в очередь
        q.put(f"data: {i}\n\n")
    q.put("data: DONE\n\n") # Сообщаем о завершении

@app.route('/start_task/<task_id>', methods=['POST'])
def start_task(task_id):
    """Эндпоинт для запуска долгой задачи."""
    if task_id in task_progress_queues and not task_progress_queues[task_id].empty():
        return {"message": f"Task {task_id} already running or has pending data."}, 409

    # Запускаем задачу в отдельном потоке
    thread = threading.Thread(target=long_running_task, args=(task_id,))
    thread.start()
    return {"message": f"Task {task_id} started."}, 202

@app.route('/sse_progress/<task_id>')
def sse_progress(task_id):
    """Эндпоинт для получения прогресса по SSE."""
    if task_id not in task_progress_queues:
        return Response("data: Task not found or not started\n\n", mimetype='text/event-stream')

    q = task_progress_queues[task_id]

    def generate_events():
        while True:
            try:
                # Получаем данные из очереди, таймаут чтобы не блокировать навсегда
                message = q.get(timeout=1)
                yield message
                if "DONE" in message:
                    del task_progress_queues[task_id] # Очищаем очередь после завершения
                    break
            except queue.Empty:
                # Если очередь пуста, отправляем "keep-alive" сообщение,
                # чтобы соединение не закрывалось по таймауту
                yield "data: keep-alive\n\n"
                time.sleep(1) # Не спамить CPU
            except GeneratorExit:
                # Клиент отключился, очищаем очередь
                print(f"Client disconnected from task {task_id}")
                if task_id in task_progress_queues:
                    # Очищаем очередь, чтобы фоновая задача не зависла
                    while not task_progress_queues[task_id].empty():
                        task_progress_queues[task_id].get_nowait()
                    del task_progress_queues[task_id]
                break # Выходим из цикла генератора

    return Response(stream_with_context(generate_events()), mimetype='text/event-stream')

if __name__ == '__main__':
    app.run(debug=True, threaded=True) # threaded=True для поддержки нескольких SSE-соединений
```

#### SSE в React (Фронтенд)

На стороне клиента для работы с SSE используется встроенный в браузер API `EventSource`.

**Основные шаги:**

1.  **Создание объекта `EventSource`:** Передайте URL вашего SSE-эндпоинта.
2.  **Обработчики событий:**
    - `onopen`: Вызывается при успешном открытии соединения.
    - `onmessage`: Вызывается при получении любого события без указанного `event:` поля. Объект `event` будет содержать поле `data` с содержимым события.
    - `onerror`: Вызывается при ошибке соединения.
    - `addEventListener(eventName, handler)`: Позволяет слушать события с конкретным полем `event:`.
3.  **Очистка:** Важно закрывать соединение `EventSource` при размонтировании компонента React, чтобы избежать утечек памяти и лишних соединений. Используйте `useEffect` с функцией очистки.

#### Пример React-компонента для получения прогресса по SSE

```javascript
import React, { useState, useEffect } from "react";

function TaskProgress({ taskId }) {
  const [progress, setProgress] = useState(0);
  const [status, setStatus] = useState("Idle");
  const [error, setError] = useState(null);

  useEffect(() => {
    // 1. Запускаем задачу на бэкенде (например, через fetch POST запрос)
    fetch(`/start_task/${taskId}`, { method: "POST" })
      .then((response) => {
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.json();
      })
      .then((data) => {
        console.log(data.message);
        setStatus("Starting...");

        // 2. После успешного запуска, открываем SSE-соединение
        const eventSource = new EventSource(`/sse_progress/${taskId}`);

        eventSource.onopen = () => {
          console.log("SSE connection opened for task:", taskId);
          setStatus("Connected, waiting for progress...");
          setError(null); // Сбрасываем ошибку при успешном подключении
        };

        eventSource.onmessage = (event) => {
          const data = event.data;
          console.log("Received SSE message:", data);

          if (data === "DONE") {
            setStatus("Completed!");
            setProgress(100);
            eventSource.close(); // Закрываем соединение после завершения
          } else if (data === "keep-alive") {
            // Игнорируем сообщения "keep-alive"
            // console.log('Keep-alive received.');
          } else if (data.startsWith("Task not found")) {
            setStatus("Error: Task not found or not started.");
            setError(data);
            eventSource.close();
          } else {
            const newProgress = parseInt(data, 10);
            if (!isNaN(newProgress)) {
              setProgress(newProgress);
              setStatus("Processing...");
            }
          }
        };

        eventSource.onerror = (errorEvent) => {
          console.error("SSE Error for task:", taskId, errorEvent);
          setStatus("Error!");
          setError("SSE connection error. Check console for details.");
          eventSource.close(); // Закрываем соединение при ошибке
        };

        // Функция очистки: закрываем EventSource при размонтировании компонента
        return () => {
          eventSource.close();
          console.log("SSE connection closed for task:", taskId);
        };
      })
      .catch((err) => {
        console.error("Failed to start task or connect SSE:", err);
        setStatus("Failed to start task.");
        setError(err.message);
      });
  }, [taskId]); // Зависимость от taskId, чтобы переподключаться при его изменении

  return (
    <div>
      <h3>Task ID: {taskId}</h3>
      <p>Status: {status}</p>
      <p>Progress: {progress}%</p>
      {error && <p style={{ color: "red" }}>Error: {error}</p>}
    </div>
  );
}

// Пример использования в App.js
function App() {
  return (
    <div className="App">
      <h1>SSE Progress Demo</h1>
      <TaskProgress taskId="my_long_operation_1" />
      <TaskProgress taskId="another_task_2" />
    </div>
  );
}

export default App;
```

#### Общий рабочий процесс для сложной операции

1.  **Клиент (React)** отправляет HTTP-запрос (например, `POST /start_task/<task_id>`) на бэкенд Flask, чтобы инициировать сложную операцию.
2.  **Бэкенд (Flask)** получает запрос:
    - Запускает сложную операцию в отдельном потоке/процессе или отправляет её в очередь задач (Celery/RQ).
    - Возвращает клиенту подтверждение (например, `202 Accepted`) и, возможно, `task_id`.
3.  **Клиент (React)**, получив подтверждение, открывает новое SSE-соединение к эндпоинту `/sse_progress/<task_id>`.
4.  **Сложная операция** (в отдельном потоке/процессе) по мере выполнения периодически отправляет свой прогресс в некий механизм обмена данными (например, `queue.Queue` в нашем примере, или Redis Pub/Sub в продакшене).
5.  **SSE-эндпоинт Flask** постоянно "слушает" этот механизм обмена данными. Как только появляются новые данные о прогрессе, он форматирует их в SSE-событие (`data: <прогресс>\n\n`) и отправляет клиенту.
6.  **Клиент (React)** получает SSE-события через `eventSource.onmessage` и обновляет UI (например, прогресс-бар).
7.  Когда сложная операция завершена, она отправляет финальное сообщение (`data: DONE\n\n`), и SSE-соединение закрывается.

#### Когда использовать SSE?

- **Однонаправленные обновления:** Идеально подходит, когда сервер является источником истины и просто "пушит" обновления клиенту.
- **Прогресс выполнения задач:** Отслеживание статуса длительных операций.
- **Ленты новостей, уведомления:** Получение новых статей, сообщений в реальном времени.
- **Меньшая сложность:** Проще в реализации и отладке, чем WebSockets, если двунаправленная связь не нужна.

#### Ограничения и соображения

- **Однонаправленность:** Если вам нужна двунаправленная связь (например, чат, интерактивные игры), используйте WebSockets.
- **Количество соединений:** Браузеры могут ограничивать количество одновременных SSE-соединений к одному домену (обычно 6-8).
- **Совместимость:** IE/Edge до недавнего времени не поддерживали `EventSource` (но современные Edge на Chromium поддерживают).
- **Масштабирование:** Для больших нагрузок и множества клиентов потребуется использовать брокер сообщений (Redis Pub/Sub, RabbitMQ, Kafka) для эффективной передачи прогресса от рабочих процессов к SSE-серверу. Flask-приложение должно быть способно обрабатывать множество одновременных SSE-соединений (например, с помощью Gunicorn + Gevent/Eventlet или асинхронного фреймворка, такого как FastAPI).
