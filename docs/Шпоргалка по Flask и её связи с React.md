### Содержание

1. [До начала работы](#0-до-начала-работы)
	1. [Установите Flask](#установите-flask)
	2. [Установите Flask-CORS](#установите-flask-cors)
2. [Как в общем выглядит модуль с Flask на Python и как это принимается из React](#1-как-в-общем-выглядит-модуль-с-flask-на-python-и-как-это-принимается-из-react)
3. [Отправка и получение данных (GET)](#2-отправка-и-получение-данных-get)
4. [Отправка данных (POST)](#3-отправка-данных-post)
5. [Как Flask работает внутри](#4-как-flask-работает-внутри)
6. [Как Flask связывается с React](#5-как-flask-связывается-с-react)
7. [Что такое REST API](#6-что-такое-rest-api)
8. [Что такое `fetch` API](#7-что-такое-fetch-api)
9. [Что такое CORS](#8-что-такое-cors)

### 0. До начала работы

Чтобы установить Flask, выполните следующие шаги:

##### Установите Flask:

    `pip install Flask`
    Эта команда установит Flask и его основные зависимости (Werkzeug, Jinja2, Click) в вашу виртуальную среду.

##### Установите Flask-CORS:

    Для взаимодействия с React-приложением, которое обычно запускается на другом порту или домене, необходимо настроить Cross-Origin Resource Sharing (CORS). Для Flask существует удобное расширение Flask-CORS.
    `pip install Flask-CORS`

### 1. Как в общем выглядит модуль с Flask на Python и как это принимается из React

Flask-приложение будет выступать в роли API-сервера, предоставляющего данные React-приложению. React-приложение, в свою очередь, будет отправлять запросы к этому API и отображать полученные данные.

**Пример кода Flask**

```python
from flask import Flask, jsonify, request
from flask_cors import CORS # Импортируем Flask-CORS

app = Flask(__name__)
CORS(app) # Инициализируем CORS для всего приложения. По умолчанию разрешает все источники.

# Простой маршрут для получения данных
@app.route('/api/data', methods=['GET'])
def get_data():
    data = {
        "message": "Привет от Flask!",
        "items": ["Элемент 1", "Элемент 2", "Элемент 3"]
    }
    return jsonify(data) # jsonify автоматически устанавливает Content-Type: application/json

# Маршрут для отправки данных (POST-запрос)
@app.route('/api/submit', methods=['POST'])
def submit_data():
    if request.is_json:
        received_data = request.get_json()
        print(f"Получены данные от React: {received_data}")
        # Здесь можно обработать данные, сохранить в базу и т.д.
        response_message = f"Данные '{received_data.get('name', 'N/A')}' успешно получены!"
        return jsonify({"status": "success", "message": response_message}), 200
    else:
        return jsonify({"status": "error", "message": "Запрос должен быть в формате JSON"}), 400

if __name__ == '__main__':
    # Запуск Flask-приложения в режиме отладки.
    # В продакшене используйте WSGI-сервер (Gunicorn, uWSGI).
    app.run(debug=True, port=5000) # Запускаем на порту 5000.
```

**Пример кода React**

```javascript
import React, { useState, useEffect } from "react";

function App() {
  const [message, setMessage] = useState("");
  const [items, setItems] = useState([]);
  const [inputValue, setInputValue] = useState("");
  const [submitStatus, setSubmitStatus] = useState("");

  // useEffect для выполнения GET-запроса при монтировании компонента
  useEffect(() => {
    // Используем fetch API для получения данных с Flask-бэкенда [18]
    fetch("http://localhost:5000/api/data")
      .then((response) => {
        // Проверяем, что ответ успешный (статус 2xx)
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.json(); // Парсим JSON-ответ
      })
      .then((data) => {
        setMessage(data.message);
        setItems(data.items);
      })
      .catch((error) => {
        console.error("Ошибка при получении данных:", error);
        setMessage("Не удалось загрузить данные.");
      });
  }, []);

  // Функция для отправки данных POST-запросом
  const handleSubmit = async (event) => {
    event.preventDefault(); // Предотвращаем перезагрузку страницы при отправке формы

    try {
      const response = await fetch("http://localhost:5000/api/submit", {
        method: "POST", // Указываем метод POST
        headers: {
          "Content-Type": "application/json", // Обязательно указываем тип контента как JSON
        },
        body: JSON.stringify({ name: inputValue }), // Преобразуем объект в JSON-строку
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();
      setSubmitStatus(data.message);
      setInputValue(""); // Очищаем поле ввода
    } catch (error) {
      console.error("Ошибка при отправке данных:", error);
      setSubmitStatus("Не удалось отправить данные.");
    }
  };

  return (
    <div style={{ padding: "20px", fontFamily: "Arial, sans-serif" }}>
      <h1>Приложение React + Flask</h1>

      <section>
        <h2>Данные с Flask (GET-запрос)</h2>
        <p>{message}</p>
        <ul>
          {items.map((item, index) => (
            <li key={index}>{item}</li>
          ))}
        </ul>
      </section>

      <section style={{ marginTop: "30px" }}>
        <h2>Отправка данных на Flask (POST-запрос)</h2>
        <form onSubmit={handleSubmit}>
          <input
            type="text"
            value={inputValue}
            onChange={(e) => setInputValue(e.target.value)}
            placeholder="Введите что-нибудь..."
            style={{ padding: "8px", marginRight: "10px" }}
          />
          <button
            type="submit"
            style={{ padding: "8px 15px", cursor: "pointer" }}>
            Отправить на Flask
          </button>
        </form>
        <p
          style={{
            marginTop: "10px",
            color: submitStatus.includes("успешно") ? "green" : "red",
          }}>
          {submitStatus}
        </p>
      </section>
    </div>
  );
}

export default App;
```

### 2. Отправка и получение данных (GET)

Взаимодействие начинается с того, что клиентское приложение (React) отправляет HTTP-запрос к серверу (Flask). Для получения данных используется метод `GET`.

На стороне Flask создается маршрут (`@app.route('/api/data', methods=['GET'])`), который при получении `GET`-запроса выполняет определенную функцию. Эта функция формирует данные, обычно в виде словаря Python, и затем преобразует их в формат JSON с помощью `jsonify` из Flask. `jsonify` также устанавливает правильный заголовок `Content-Type: application/json` в ответе, что важно для корректной интерпретации данных на стороне клиента.

На стороне React, в компоненте, используется хук `useEffect` для выполнения запроса при монтировании компонента. Внутри `useEffect` вызывается нативный `fetch` API браузера. `fetch('http://localhost:5000/api/data')` отправляет запрос. Полученный ответ обрабатывается цепочкой `.then()`: сначала проверяется статус ответа (`response.ok`), затем ответ парсится как JSON (`response.json()`). Полученные данные используются для обновления состояния компонента (`setMessage`, `setItems`), что приводит к перерисовке UI и отображению данных, полученных с Flask. Обработка ошибок (`.catch()`) необходима для реакции на проблемы с сетью или сервером.

### 3. Отправка данных (POST)

Для отправки данных с клиента на сервер, например, при заполнении формы, используется метод `POST`.

На стороне React создается форма с полем ввода и кнопкой. При отправке формы (событие `onSubmit`) вызывается асинхронная функция `handleSubmit`. В этой функции `fetch` вызывается с дополнительными параметрами: `method: 'POST'`, `headers: { 'Content-Type': 'application/json' }` и `body: JSON.stringify({ name: inputValue })`. Заголовок `Content-Type: application/json` информирует сервер о том, что тело запроса содержит JSON-данные. `JSON.stringify()` преобразует JavaScript-объект в строку JSON, так как `fetch` ожидает строковое тело запроса.

На стороне Flask, маршрут (`@app.route('/api/submit', methods=['POST'])`) настроен на прием `POST`-запросов. Внутри функции-обработчика используется объект `request` из Flask. `request.is_json` проверяет, был ли запрос отправлен с заголовком `Content-Type: application/json`. Если да, `request.get_json()` автоматически парсит JSON-тело запроса в словарь Python. Полученные данные обрабатываются, и сервер отправляет ответ клиенту, указывая статус операции.

### 4. Как Flask работает внутри

Flask — это микрофреймворк для веб-разработки на Python. Приставка "микро" означает, что он предоставляет только базовые функции для создания веб-приложений, такие как маршрутизация, обработка запросов и ответов, и не включает встроенные решения для баз данных, аутентификации или других сложных задач. Это дает разработчику большую гибкость в выборе инструментов и библиотек.

В основе Flask лежат две ключевые библиотеки:

- **Werkzeug**: это набор инструментов WSGI (Web Server Gateway Interface), который обрабатывает запросы и ответы. WSGI — это стандарт взаимодействия между веб-сервером (например, Gunicorn, Apache с mod_wsgi) и Python-приложением. Он позволяет веб-серверу передавать запросы в Python-приложение и получать ответы.
- **Jinja2**: это мощный и гибкий шаблонизатор, используемый для генерации HTML-страниц на основе данных.

Когда клиент (например, браузер или React-приложение) отправляет HTTP-запрос на сервер, происходит следующий цикл обработки запроса-ответа во Flask:

1. **Клиентский запрос**: Браузер отправляет HTTP-запрос (GET, POST и т.д.) на URL-адрес.
2. **Веб-сервер/WSGI-сервер**: Веб-сервер (например, Nginx) получает запрос и передает его WSGI-серверу (например, Gunicorn), который, в свою очередь, передает его Flask-приложению.
3. **Маршрутизация**: Flask-приложение получает запрос. На основе URL-адреса и HTTP-метода (GET, POST и т.д.) Flask определяет, какая функция-обработчик (так называемая "view function") должна быть вызвана. Это сопоставление URL-адресов с функциями называется маршрутизацией и определяется с помощью декоратора `@app.route()`.
4. **Объект запроса (`request`)**: Flask создает объект `request`, который содержит всю информацию о входящем запросе: HTTP-метод, заголовки, параметры URL, данные формы, JSON-тело и т.д.,
5. **Выполнение функции-обработчика**: Вызывается соответствующая функция-обработчик. Внутри этой функции разработчик получает доступ к данным запроса через объект `request`, выполняет необходимую логику (например, обращение к базе данных, вычисления) и формирует данные для ответа.
6. **Объект ответа (`response`)**: Функция-обработчик возвращает данные, которые Flask преобразует в объект `response`. Это может быть строка HTML, JSON-данные, перенаправление или другой тип ответа. Flask автоматически устанавливает необходимые заголовки HTTP.
7. **Отправка ответа**: Объект `response` отправляется обратно через WSGI-сервер и веб-сервер клиенту.

### 5. Как Flask связывается с React

Flask и React взаимодействуют по принципу клиент-серверной архитектуры, где они выступают как отдельные, независимые компоненты. React отвечает за "фронтенд" (пользовательский интерфейс), а Flask — за "бэкенд" (логику сервера, обработку данных, API).

Связь между ними осуществляется через **API (Application Programming Interface)**, обычно с использованием принципов **REST (Representational State Transfer)**. React-приложение отправляет HTTP-запросы (GET, POST, PUT, DELETE и т.д.) на определенные URL-адреса, предоставляемые Flask-бэкендом. Flask обрабатывает эти запросы, выполняет необходимые операции и отправляет обратно HTTP-ответы, чаще всего содержащие данные в формате JSON.

Этот подход позволяет разрабатывать фронтенд и бэкенд независимо друг от друга, используя разные языки и технологии.

### 6. Что такое REST API

**REST API** (Representational State Transfer Application Programming Interface) — это архитектурный стиль для построения распределенных систем, таких как веб-сервисы. Он не является протоколом, а скорее набором принципов и ограничений, которые определяют, как должна быть организована связь между клиентом и сервером.

Ключевые принципы REST API:

- **Клиент-серверная архитектура**: Четкое разделение между клиентской частью (которая запрашивает ресурсы) и серверной частью (которая предоставляет ресурсы). Это позволяет разрабатывать и масштабировать их независимо.
- **Отсутствие состояния (Stateless)**: Каждый запрос от клиента к серверу должен содержать всю информацию, необходимую для обработки этого запроса. Сервер не хранит никакого состояния клиента между запросами. Это упрощает масштабирование и повышает надежность.
- **Кэшируемость (Cacheable)**: Ответы сервера могут быть помечены как кэшируемые или некэшируемые. Это позволяет клиентам кэшировать данные, что улучшает производительность и снижает нагрузку на сервер.
- **Единообразный интерфейс (Uniform Interface)**: Это центральный принцип REST. Он включает несколько ограничений:
  - **Идентификация ресурсов**: Ресурсы (данные или сервисы) идентифицируются с помощью уникальных URL (Uniform Resource Locators).
  - **Манипуляция ресурсами через представления**: Клиент взаимодействует с ресурсами через их представления (например, JSON или XML).
  - **Самоописывающие сообщения**: Каждое сообщение (запрос или ответ) содержит достаточно информации для его интерпретации.
  - **HATEOAS (Hypermedia As The Engine Of Application State)**: Ресурсы могут содержать ссылки на другие связанные ресурсы, что позволяет клиенту динамически перемещаться по API.
- **Многослойная система (Layered System)**: Клиент может не знать, взаимодействует ли он напрямую с конечным сервером или с посредниками (прокси, балансировщики нагрузки).
- **Код по требованию (Code-On-Demand)** (опционально): Сервер может временно расширять функциональность клиента, передавая исполняемый код (например, JavaScript).

REST API использует стандартные HTTP-методы для выполнения операций с ресурсами:

- `GET`: Получение ресурса или коллекции ресурсов.
- `POST`: Создание нового ресурса.
- `PUT`: Полное обновление существующего ресурса.
- `PATCH`: Частичное обновление существующего ресурса.
- `DELETE`: Удаление ресурса.

### 7. Что такое `fetch` API

`fetch` API — это современный, нативный JavaScript-интерфейс, предоставляемый браузерами, для выполнения сетевых запросов (например, HTTP-запросов) к серверам. Он является более мощной и гибкой заменой устаревшему `XMLHttpRequest` (XHR).

Основные особенности `fetch` API:

- **Основан на промисах (Promises)**: `fetch` возвращает `Promise`, что упрощает работу с асинхронными операциями и позволяет использовать цепочки `.then()` и `.catch()` для обработки успешных ответов и ошибок, а также синтаксис `async/await`.
- **Гибкость**: Позволяет настраивать различные аспекты запроса, такие как HTTP-метод (GET, POST и т.д.), заголовки, тело запроса и режим кэширования.
- **Поддержка различных типов данных**: Может отправлять и получать данные в различных форматах, включая JSON, FormData, Blob и текст.

Пример базового использования `fetch` для GET-запроса:

```javascript
fetch("https://api.example.com/data")
  .then((response) => response.json()) // Парсим ответ как JSON
  .then((data) => console.log(data)) // Обрабатываем полученные данные
  .catch((error) => console.error("Ошибка:", error)); // Обработка ошибок
```

Пример использования `fetch` для POST-запроса с JSON-телом:

```javascript
fetch('https://api.example.com/submit', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({ name: 'Пример' }) // Отправляем JSON-строку
})
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error('Ошибка:', [[16]](https://testdriven.io/blog/how-are-requests-processed-in-flask/) error));
```

### 8. Что такое CORS

**CORS** (Cross-Origin Resource Sharing — совместное использование ресурсов между разными источниками) — это механизм безопасности, реализованный в веб-браузерах, который ограничивает, какие веб-страницы могут запрашивать ресурсы с других доменов, чем тот, с которого была загружена сама страница.

Причина существования CORS — это **политика одного источника (Same-Origin Policy)**. Эта политика безопасности запрещает JavaScript-коду, запущенному на одной веб-странице, делать запросы к ресурсам, расположенным на другом "источнике" (домене, протоколе или порту), если это явно не разрешено. Например, если ваше React-приложение запущено на `http://localhost:3000`, а Flask-бэкенд на `http://localhost:5000`, то без CORS браузер заблокирует запросы от React к Flask, так как они находятся на разных портах (разные источники).

Для того чтобы разрешить кросс-доменные запросы, сервер (в данном случае Flask) должен явно указать, какие источники, методы и заголовки разрешены. Это делается путем добавления специальных HTTP-заголовков в ответы сервера.

Расширение **Flask-CORS** упрощает эту задачу, позволяя легко настроить необходимые заголовки CORS в вашем Flask-приложении. Например, `CORS(app)` в Flask-приложении по умолчанию разрешает запросы со всех источников (`*`) для всех методов, что удобно для разработки. В продакшене рекомендуется явно указывать разрешенные источники для повышения безопасности.
