### Содержание

1.  [BeautifulSoup4 (Python)](#beautifulsoup4-python)
    1.  [Что такое BeautifulSoup4](#что-такое-beautifulsoup4)
    2.  [Установка](#установка)
    3.  [Основные шаги и примеры](#основные-шаги-и-примеры)
        1.  [Импорт и парсинг HTML/XML](#импорт-и-парсинг-htmlxml)
        2.  [Навигация по дереву](#навигация-по-дереву)
        3.  [Поиск элементов (`find()`, `find_all()`)](#поиск-элементов-find-find_all)
        4.  [Доступ к атрибутам и тексту](#доступ-к-атрибутам-и-тексту)
        5.  [Модификация HTML-дерева](#модификация-html-дерева)
    4.  [Примеры использования BeautifulSoup4](#примеры-использования-beautifulsoup4)
2.  [Markdown (Python)](#markdown-python)
    1.  [Что такое Markdown (библиотека Python)](#что-такое-markdown-библиотека-python)
    2.  [Установка](#установка-1)
    3.  [Основные шаги и примеры](#основные-шаги-и-примеры-1)
        1.  [Базовая конвертация](#базовая-конвертация)
        2.  [Использование расширений](#использование-расширений)
    4.  [Примеры использования Markdown](#примеры-использования-markdown)
3.  [Pathlib (Python)](#pathlib-python)
    1.  [Что такое pathlib](#что-такое-pathlib)
    2.  [Зачем использовать pathlib?](#зачем-использовать-pathlib)
    3.  [Установка](#установка)
    4.  [Основные шаги и примеры](#основные-шаги-и-примеры)
        1.  [Создание объектов Path](#создание-объектов-path)
        2.  [Доступ к компонентам пути](#доступ-к-компонентам-пути)
        3.  [Объединение путей](#объединение-путей)
        4.  [Проверка существования и типа пути](#проверка-существования-и-типа-пути)
        5.  [Создание и удаление директорий](#создание-и-удаление-директорий)
        6.  [Создание и удаление файлов](#создание-и-удаление-файлов)
        7.  [Переименование и перемещение](#переименование-и-перемещение)
        8.  [Итерация по содержимому директории](#итерация-по-содержимому-директории)
        9.  [Поиск файлов по шаблону (`glob`, `rglob`)](#поиск-файлов-по-шаблону-glob-rglob)
        10. [Чтение и запись файлов](#чтение-и-запись-файлов)
    5.  [Примеры использования pathlib](#примеры-использования-pathlib)
4.  [JSON (Python)](#json-python)
    1. [Основные функции](#основные-функции)
       1. [`json.dumps(obj, ...)`](#jsondumpsobj-)
       2. [`json.loads(json_string, ...)`](#jsonloadsjson_string-)
       3. [`json.dump(obj, fp, ...)`](#jsondumpobj-fp-)
       4. [`json.load(fp, ...)`](#jsonloadfp-)
    2. [Соответствие типов Python и JSON](#соответствие-типов-python-и-json)
5.  [Регулярные выражения (теория)](#регулярные-выражения-теория)
    1. [Что такое регулярные выражения](#что-такое-регулярные-выражения)
    2. [Основные понятия](#основные-понятия)
    3. [Метасимволы](#метасимволы)
    4. [Квантификаторы](#квантификаторы)
    5. [Группы и захват](#группы-и-захват)
    6. [Флаги](#флаги)
6.  [Регулярные выражения в Python](#регулярные-выражения-в-python)
    1. [Модуль `re`](#модуль-re)
    2. [Функции модуля `re`](#функции-модуля-re)
       1. [`re.search()`](#research)
       2. [`re.match()`](#rematch)
       3. [`re.findall()`](#refindall)
       4. [`re.sub()`](#resub)
       5. [`re.compile()`](#recompile)
    3. [Объект совпадения (Match Object)](#объект-совпадения-match-object)
7.  [Регулярные выражения в JavaScript](#регулярные-выражения-в-javascript)
    1. [Создание регулярных выражений](#создание-регулярных-выражений)
    2. [Флаги регулярных выражений](#флаги-регулярных-выражений)
    3. [Методы объекта `RegExp`](#методы-объекта-regexp)
       1. [`RegExp.prototype.test()`](#regexpprototypetest)
       2. [`RegExp.prototype.exec()`](#regexpprototypeexec)
    4. [Методы строковых объектов](#методы-строковых-объектов)
       1. [`String.prototype.match()`](#stringprototypematch)
       2. [`String.prototype.search()`](#stringprototypesearch)
       3. [`String.prototype.replace()`](#stringprototypereplace)
       4. [`String.prototype.split()`](#stringprototypesplit)

---

### BeautifulSoup4 (Python)

#### Что такое BeautifulSoup4

BeautifulSoup4 (часто сокращается как `bs4`) — это Python-библиотека для парсинга HTML и XML документов. Она создает дерево разбора (parse tree) из полученного содержимого, что позволяет легко извлекать данные из HTML-страниц, перемещаться по дереву, искать элементы по различным критериям и даже модифицировать структуру. `bs4` особенно полезна для веб-скрейпинга.

#### Установка

BeautifulSoup4 устанавливается через `pip`:

```bash
pip install beautifulsoup4
```

Также может потребоваться установить парсер, например `lxml` (рекомендуется для производительности) или `html.parser` (встроен в Python).

```bash
pip install lxml
```

#### Основные шаги и примеры

##### Импорт и парсинг HTML/XML

Для начала импортировать и создать объект, передав ему HTML-строку или файловый объект, а также указав используемый парсер.

```python
from bs4 import BeautifulSoup

html_doc = """
<html><head><title>Моя страница</title></head>
<body>
    <p class="title"><b>Заголовок</b></p>
    <a href="http://example.com/link1" class="external" id="link1">Ссылка 1</a>
    <a href="http://example.com/link2" class="internal" id="link2">Ссылка 2</a>
    <p>Еще один параграф.</p>
</body></html>
"""

# Создание объекта BeautifulSoup с использованием парсера 'lxml'
soup = BeautifulSoup(html_doc, 'lxml')

print(soup.prettify()) # Выводит красиво отформатированный HTML
```

##### Навигация по дереву

К элементам можно обращаться как к атрибутам объекта `soup` или других тегов.

```python
# Доступ к тегу <title>
title_tag = soup.title
print(f"Тег title: {title_tag}")
print(f"Текст в title: {title_tag.string}")

# Доступ к первому тегу <p>
first_p_tag = soup.p
print(f"Первый тег p: {first_p_tag}")

# Доступ к родителю, потомкам, соседям
body_tag = soup.body
print(f"Родитель body: {body_tag.parent.name}") # html
print(f"Первый потомок body: {body_tag.contents[0].name}") # p
print(f"Следующий сосед p: {first_p_tag.next_sibling.next_sibling.name}") # a
```

##### Поиск элементов (`find()`, `find_all()`)

Это наиболее мощные методы для поиска элементов по различным критериям.

- `find(name, attrs, recursive, string, **kwargs)`: Находит **первое** совпадение.
- `find_all(name, attrs, recursive, string, limit, **kwargs)`: Находит **все** совпадения.

Аргументы:

- `name`: Имя тега (строка, список строк, регулярное выражение, функция).
- `attrs`: Словарь атрибутов.
- `class_`: Поиск по CSS-классу (ключевое слово `class` зарезервировано в Python).
- `id`: Поиск по ID.
- `string`: Поиск по тексту внутри тега.

```python
# Найти все теги <a>
all_links = soup.find_all('a')
for link in all_links:
    print(f"Найдена ссылка: {link}")

# Найти тег <p> с классом "title"
title_paragraph = soup.find('p', class_='title')
print(f"Параграф с классом 'title': {title_paragraph}")

# Найти ссылку с id "link2"
link2 = soup.find(id='link2')
print(f"Ссылка с id 'link2': {link2}")

# Найти все теги, содержащие "Ссылка" в тексте
links_with_text = soup.find_all(string=lambda text: "Ссылка" in text)
print(f"Теги, содержащие 'Ссылка': {links_with_text}")
```

##### Доступ к атрибутам и тексту

```python
# Доступ к атрибутам тега как к словарю
first_link = soup.a
print(f"Атрибуты первой ссылки: {first_link.attrs}")
print(f"Значение href: {first_link['href']}")
print(f"Значение class: {first_link['class']}")

# Получение текста внутри тега
print(f"Текст первой ссылки: {first_link.get_text()}")
print(f"Текст параграфа с заголовком: {title_paragraph.get_text()}")
```

##### Модификация HTML-дерева

BeautifulSoup позволяет изменять содержимое, атрибуты и структуру HTML-дерева.

```python
# Изменение текста тега
soup.title.string = "Новый заголовок"
print(f"Измененный заголовок: {soup.title.string}")

# Изменение атрибута
first_link = soup.a
first_link['href'] = "http://new-example.com"
print(f"Измененная ссылка: {first_link}")

# Добавление нового тега
new_tag = soup.new_tag("h1")
new_tag.string = "Новый заголовок H1"
soup.body.append(new_tag)
print(f"HTML после добавления: {soup.body.prettify()}")

# Удаление тега
soup.find('p', class_='title').decompose() # Удаляет тег и его содержимое
print(f"HTML после удаления: {soup.body.prettify()}")
```

#### Примеры использования BeautifulSoup4

- **Парсинг данных с веб-страниц**: Извлечение новостных заголовков, цен товаров, контактной информации.
- **Анализ структуры HTML**: Понимание того, как устроены веб-страницы, для целей тестирования или SEO-анализа.
- **Очистка HTML**: Удаление нежелательных тегов или атрибутов из HTML-кода.
- **Извлечение изображений**: Поиск всех тегов `<img>` и извлечение их атрибутов `src`.

---

### Markdown (Python)

#### Что такое Markdown (библиотека Python)

Библиотека `markdown` (иногда также `python-markdown2`) — это парсер Markdown на Python, который преобразует текст, написанный в синтаксисе Markdown, в HTML. Markdown — это легковесный язык разметки, предназначенный для создания форматированного текста с использованием простого текстового редактора. Он широко используется для написания документации, сообщений на форумах, блогов и многого другого.

#### Установка

Библиотека `markdown` устанавливается через `pip`:

```bash
pip install markdown
```

#### Основные шаги и примеры

##### Базовая конвертация

Для конвертации Markdown-текста в HTML используется функция `markdown.markdown()`.

````python
import markdown

markdown_text = """
# Привет, Markdown!

Это **жирный** текст и *курсив*.

## Список:
* Элемент 1
* Элемент 2

[Ссылка на Google](https://www.google.com)

```python
print("Hello, world!")
```

"""

html = markdown.markdown(markdown_text)
print(html)

````

Предполагаемый вывод:

```html
<h1>Привет, Markdown!</h1>
<p>Это <strong>жирный</strong> текст и <em>курсив</em>.</p>
<h2>Список:</h2>
<ul>
  <li>Элемент 1</li>
  <li>Элемент 2</li>
</ul>
<p><a href="https://www.google.com">Ссылка на Google</a></p>
<pre><code class="language-python">print("Hello, world!")
</code></pre>
```

##### Использование расширений

Библиотека `markdown` поддерживает множество расширений, которые добавляют дополнительную функциональность или изменяют поведение парсера. Расширения передаются в функцию `markdown.markdown()` через аргумент `extensions`.

Некоторые популярные расширения:

- `extra`: Включает несколько полезных расширений, таких как таблицы, списки определений, сокращения и т.д.
- `codehilite`: Подсветка синтаксиса для блоков кода (требует установки `Pygments`: `pip install Pygments`).
- `toc`: Генерация оглавления.
- `fenced_code`: Поддержка блоков кода, окруженных тройными апострофами (```).

````python
import markdown

markdown_text_with_extra = """
# Заголовок

## Подзаголовок

Это таблица:

| Заголовок 1 | Заголовок 2 |
|-------------|-------------|
| Ячейка 1    | Ячейка 2    |
| Ячейка 3    | Ячейка 4    |

```python
def hello():
    return "World"
```

"""

# Использование расширения 'extra' и 'codehilite'

html_extra = markdown.markdown(markdown_text_with_extra, extensions=['extra', 'codehilite'])
print("\n--- HTML с расширениями extra и codehilite ---")
print(html_extra)

# Использование расширения 'toc' для генерации оглавления

markdown_text_with_toc = """

# Первый раздел

Текст первого раздела.

## Второй раздел

Текст второго раздела.

### Подраздел

Текст подраздела.
"""

md = markdown.Markdown(extensions=['toc'])
html_toc = md.convert(markdown_text_with_toc)
toc_html = md.toc # Оглавление доступно через атрибут .toc
print("\n--- HTML с оглавлением ---")
print(html_toc)
print("\n--- Оглавление ---")
print(toc_html)

````

#### Примеры использования Markdown

- **Генерация HTML из пользовательского ввода**: Если пользователи вводят текст в формате Markdown (например, в комментариях, сообщениях на форумах), библиотека может преобразовать его в безопасный HTML для отображения.
- **Создание статических сайтов/блогов**: Написание контента в Markdown и автоматическая конвертация его в HTML-страницы.
- **Документация**: Подготовка документации в Markdown и ее рендеринг в HTML для веб-просмотра.
- **Преобразование файлов**: Конвертация `.md` файлов в `.html`.

---

### Pathlib (Python)

#### Что такое pathlib

`pathlib` — это встроенный модуль Python, представленный в Python 3.4, который предоставляет объектно-ориентированный подход к работе с путями файловой системы. Вместо использования строковых операций для манипуляций с путями, `pathlib` позволяет работать с путями как с объектами `Path`, что делает код более читаемым, надежным и кроссплатформенным.

#### Зачем использовать pathlib?

- **Объектно-ориентированный подход**: Пути представлены как объекты `Path`, что позволяет вызывать методы напрямую на этих объектах, вместо использования функций из `os.path` с передачей строковых путей.
- **Читаемость кода**: Методы `Path` часто более интуитивно понятны, чем их аналоги в `os.path`.
- **Кроссплатформенность**: `pathlib` автоматически обрабатывает различия в разделителях путей (`/` или `\`) между операционными системами.
- **Цепочечные вызовы**: Методы `Path` часто возвращают новые объекты `Path`, что позволяет удобно объединять операции в цепочки.
- **Безопасность**: Уменьшает вероятность ошибок, связанных с ручной конкатенацией строк для создания путей.

#### Установка

`pathlib` является частью стандартной библиотеки Python, начиная с версии 3.4. Его не нужно устанавливать отдельно. Достаточно просто импортировать:

```python
from pathlib import Path
```

#### Основные шаги и примеры

##### Создание объектов Path

Объекты `Path` могут быть созданы из строк, представляющих пути.

```python
from pathlib import Path
import os

# Текущая рабочая директория
current_dir = Path.cwd()
print(f"Текущая директория: {current_dir}")

# Абсолютный путь
absolute_path = Path("/home/user/documents/report.txt") # Linux/macOS
# absolute_path = Path("C:\\Users\\User\\Documents\\report.txt") # Windows
print(f"Абсолютный путь: {absolute_path}")

# Относительный путь
relative_path = Path("my_folder/my_file.txt")
print(f"Относительный путь: {relative_path}")

# Путь к домашней директории пользователя
home_dir = Path.home()
print(f"Домашняя директория: {home_dir}")
```

##### Доступ к компонентам пути

Объекты `Path` предоставляют удобные атрибуты для доступа к различным частям пути.

```python
from pathlib import Path

file_path = Path("/home/user/documents/report.pdf")

print(f"Имя файла с расширением: {file_path.name}")    # report.pdf
print(f"Расширение файла: {file_path.suffix}")         # .pdf
print(f"Имя файла без расширения: {file_path.stem}")   # report
print(f"Родительская директория: {file_path.parent}")  # /home/user/documents
print(f"Все компоненты пути: {file_path.parts}")       # ('/', 'home', 'user', 'documents', 'report.pdf')
print(f"Является ли абсолютным: {file_path.is_absolute()}") # True
```

##### Объединение путей

Используйте оператор `/` для объединения объектов `Path` или строк.

```python
from pathlib import Path

base_path = Path("/home/user")
sub_folder = "projects"
file_name = "main.py"

full_path = base_path / sub_folder / file_name
print(f"Полный путь: {full_path}") # /home/user/projects/main.py

# Объединение с другим Path объектом
another_path = Path("data") / "input.csv"
combined_path = full_path.parent / another_path
print(f"Объединенный путь: {combined_path}") # /home/user/projects/data/input.csv
```

##### Проверка существования и типа пути

```python
from pathlib import Path
import os

# Создадим временные файлы/папки для примера
# (В реальном коде используйте try-finally для очистки)
Path("test_dir").mkdir(exist_ok=True)
Path("test_dir/test_file.txt").touch()

my_dir = Path("test_dir")
my_file = Path("test_dir/test_file.txt")
non_existent = Path("non_existent.txt")

print(f"Существует ли test_dir: {my_dir.exists()}")     # True
print(f"Является ли test_dir директорией: {my_dir.is_dir()}") # True
print(f"Является ли test_dir файлом: {my_dir.is_file()}")   # False

print(f"Существует ли test_file.txt: {my_file.exists()}")   # True
print(f"Является ли test_file.txt директорией: {my_file.is_dir()}") # False
print(f"Является ли test_file.txt файлом: {my_file.is_file()}")   # True

print(f"Существует ли non_existent.txt: {non_existent.exists()}") # False

# Очистка
my_file.unlink() # Удалить файл
my_dir.rmdir()   # Удалить пустую директорию
```

##### Создание и удаление директорий

```python
from pathlib import Path

# Создание одной директории
new_folder = Path("my_new_folder")
new_folder.mkdir(exist_ok=True) # exist_ok=True предотвращает ошибку, если папка уже существует
print(f"Создана директория: {new_folder}")

# Создание вложенных директорий (как mkdir -p)
nested_folders = Path("parent/child/grandchild")
nested_folders.mkdir(parents=True, exist_ok=True)
print(f"Созданы вложенные директории: {nested_folders}")

# Удаление пустой директории
new_folder.rmdir()
print(f"Удалена директория: {new_folder}")

# Для удаления непустой директории используйте shutil.rmtree
import shutil
shutil.rmtree(nested_folders.parent.parent) # Удалит 'parent' со всем содержимым
print(f"Удалены вложенные директории: {nested_folders.parent.parent}")
```

##### Создание и удаление файлов

```python
from pathlib import Path

# Создание пустого файла (как touch)
empty_file = Path("empty_file.txt")
empty_file.touch()
print(f"Создан пустой файл: {empty_file}")

# Удаление файла
empty_file.unlink()
print(f"Удален файл: {empty_file}")
```

##### Переименование и перемещение

```python
from pathlib import Path

# Создадим файл для примера
original_file = Path("old_name.txt")
original_file.touch()

# Переименование файла
new_file_name = Path("new_name.txt")
original_file.rename(new_file_name)
print(f"Файл переименован в: {new_file_name}")

# Перемещение файла в другую директорию
target_dir = Path("moved_files")
target_dir.mkdir(exist_ok=True)
moved_file = new_file_name.rename(target_dir / new_file_name.name)
print(f"Файл перемещен в: {moved_file}")

# Очистка
moved_file.unlink()
target_dir.rmdir()
```

##### Итерация по содержимому директории

Метод `iterdir()` возвращает итератор по содержимому директории (файлы и поддиректории).

```python
from pathlib import Path

# Создадим структуру для примера
Path("my_project").mkdir(exist_ok=True)
Path("my_project/main.py").touch()
Path("my_project/utils.py").touch()
Path("my_project/data").mkdir(exist_ok=True)
Path("my_project/data/config.json").touch()

project_root = Path("my_project")

print(f"Содержимое {project_root}:")
for item in project_root.iterdir():
    print(f"- {item.name} (директория: {item.is_dir()}, файл: {item.is_file()})")

# Очистка
import shutil
shutil.rmtree(project_root)
```

##### Поиск файлов по шаблону (`glob`, `rglob`)

- `glob(pattern)`: Поиск файлов, соответствующих шаблону, только в текущей директории.
- `rglob(pattern)`: Рекурсивный поиск файлов, соответствующих шаблону, во всех поддиректориях.

```python
from pathlib import Path
import os

# Создадим структуру для примера
Path("search_test").mkdir(exist_ok=True)
Path("search_test/file1.txt").touch()
Path("search_test/file2.log").touch()
Path("search_test/sub_dir").mkdir(exist_ok=True)
Path("search_test/sub_dir/another.txt").touch()
Path("search_test/sub_dir/data.csv").touch()

search_root = Path("search_test")

print("Все .txt файлы в search_test:")
for p in search_root.glob("*.txt"):
    print(f"- {p}")

print("\nВсе .txt файлы рекурсивно:")
for p in search_root.rglob("*.txt"):
    print(f"- {p}")

print("\nВсе файлы, начинающиеся на 'file':")
for p in search_root.glob("file*"):
    print(f"- {p}")

# Очистка
import shutil
shutil.rmtree(search_root)
```

##### Чтение и запись файлов

`pathlib` предоставляет удобные методы `read_text()`, `write_text()`, `read_bytes()`, `write_bytes()` для работы с содержимым файлов.

```python
from pathlib import Path

# Запись текста в файл
file_to_write = Path("my_document.txt")
file_to_write.write_text("Это первая строка.\nЭто вторая строка.")
print(f"Записано в файл: {file_to_write}")

# Чтение текста из файла
content = file_to_write.read_text()
print(f"Прочитано из файла:\n{content}")

# Добавление текста в файл (режим 'a' для append)
with file_to_write.open('a', encoding='utf-8') as f:
    f.write("\nЭто добавленная строка.")
print(f"Добавлено в файл: {file_to_write.read_text()}")

# Работа с бинарными данными (например, изображения)
binary_file = Path("binary_data.bin")
binary_file.write_bytes(b'\x00\x01\x02\x03')
print(f"Записаны бинарные данные в: {binary_file}")
binary_content = binary_file.read_bytes()
print(f"Прочитаны бинарные данные: {binary_content}")

# Очистка
file_to_write.unlink()
binary_file.unlink()
```

#### Примеры использования pathlib

- **Управление конфигурационными файлами**: Легкое создание, чтение и изменение файлов конфигурации в различных форматах.
- **Обработка данных**: Поиск и обработка файлов определенного типа в директориях и поддиректориях.
- **Автоматизация файловых операций**: Создание скриптов для организации файлов, резервного копирования, перемещения и удаления.
- **Разработка кроссплатформенных приложений**: Гарантирует, что код, работающий с файловой системой, будет вести себя одинаково на Windows, Linux и macOS.

### JSON (Python)

Модуль `json` в Python позволяет работать с данными в формате JSON (JavaScript Object Notation), который широко используется для обмена данными между приложениями.

#### Основные функции

##### `json.dumps(obj, ...)`

Преобразует Python-объект (`obj`) в JSON-строку.

**Аргументы:**
`indent` (опционально): делает JSON-строку удобочитаемой (например, `indent=4`).
`ensure_ascii` (опционально): если `False`, позволяет использовать не-ASCII символы напрямую (по умолчанию `True`).

**Пример:**

```python
import json

data = {
    "name": "Алиса",
    "age": 30,
    "isStudent": False,
    "courses": ["Математика", "Физика"]
}

json_string = json.dumps(data, indent=4, ensure_ascii=False)
print(json_string)
# Вывод:
# {
#     "name": "Алиса",
#     "age": 30,
#     "isStudent": false,
#     "courses": [
#         "Математика",
#         "Физика"
#     ]
# }
```

##### `json.loads(json_string, ...)`

Преобразует JSON-строку (`json_string`) обратно в Python-объект.

**Пример:**

```python
import json

json_data_str = '{"product": "Laptop", "price": 1200.50, "inStock": true}'
python_obj = json.loads(json_data_str)
print(python_obj)
```

Предполагаемый вывод: `{'product': 'Laptop', 'price': 1200.5, 'inStock': True}`

##### `json.dump(obj, fp, ...)`

Записывает Python-объект (`obj`) в JSON-файл (`fp` - файловый объект).

**Пример:**

```python
import json

data_to_save = {"city": "Москва", "population": 13000000}
with open("data.json", "w", encoding="utf-8") as f:
    json.dump(data_to_save, f, indent=4, ensure_ascii=False)
# Создаст файл data.json с содержимым:
# {
#     "city": "Москва",
#     "population": 13000000
# }
```

##### `json.load(fp, ...)`

Читает JSON-данные из файла (`fp` - файловый объект) и преобразует их в Python-объект.

**Пример:**

```python
import json

# Предполагаем, что data.json был создан ранее
with open("data.json", "r", encoding="utf-8") as f:
    loaded_data = json.load(f)
print(loaded_data)
# Вывод: {'city': 'Москва', 'population': 13000000}
```

#### Соответствие типов Python и JSON

| Python          | JSON     |
| :-------------- | :------- |
| `dict`          | `object` |
| `list`, `tuple` | `array`  |
| `str`           | `string` |
| `int`, `float`  | `number` |
| `True`          | `true`   |
| `False`         | `false`  |
| `None`          | `null`   |

**Важно:** Ключи в JSON-объектах всегда должны быть строками. Python-словари с нестроковыми ключами не могут быть напрямую сериализованы в JSON.

1.  [Что такое регулярные выражения](#что-такое-регулярные-выражения)
    1.  [Основные понятия](#основные-понятия)
    2.  [Метасимволы](#метасимволы)
    3.  [Квантификаторы](#квантификаторы)
    4.  [Группы и захват](#группы-и-захват)
    5.  [Флаги](#флаги)
2.  [Регулярные выражения в Python](#регулярные-выражения-в-python)
    1.  [Модуль `re`](#модуль-re)
    2.  [Функции модуля `re`](#функции-модуля-re)
        1.  [`re.search()`](#re.search)
        2.  [`re.match()`](#re.match)
        3.  [`re.findall()`](#re.findall)
        4.  [`re.sub()`](#re.sub)
        5.  [`re.compile()`](#re.compile)
    3.  [Объект совпадения (Match Object)](#объект-совпадения-match-object)
3.  [Регулярные выражения в JavaScript](#регулярные-выражения-в-javascript)
    1.  [Создание регулярных выражений](#создание-регулярных-выражений)
    2.  [Флаги регулярных выражений](#флаги-регулярных-выражений)
    3.  [Методы объекта `RegExp`](#методы-объекта-regexp)
        1.  [`RegExp.prototype.test()`](#regexp.prototype.test)
        2.  [`RegExp.prototype.exec()`](#regexp.prototype.exec)
    4.  [Методы строковых объектов](#методы-строковых-объектов)
        1.  [`String.prototype.match()`](#string.prototype.match)
        2.  [`String.prototype.search()`](#string.prototype.search)
        3.  [`String.prototype.replace()`](#string.prototype.replace)
        4.  [`String.prototype.split()`](#string.prototype.split)

---

### Регулярные выражения (теория)

##### Что такое регулярные выражения

Регулярные выражения (RegEx, RegExp) — это мощный инструмент для поиска, замены и извлечения текстовых шаблонов в строках. Они представляют собой последовательность символов, которая определяет шаблон поиска.

##### Основные понятия

- **Шаблон (Pattern)**: Последовательность символов, описывающая искомый фрагмент текста.
- **Совпадение (Match)**: Обнаружение фрагмента текста, соответствующего шаблону.

##### Метасимволы

Специальные символы, которые имеют особое значение в регулярных выражениях:

- `.` (точка): Любой символ, кроме символа новой строки.
- `\d`: Любая цифра (эквивалентно `[0-9]`).
- `\D`: Любой символ, кроме цифры (эквивалентно `[^0-9]`).
- `\w`: Любой буквенно-цифровой символ (буквы, цифры, `_`). Эквивалентно `[a-zA-Z0-9_]`.
- `\W`: Любой символ, кроме буквенно-цифрового. Эквивалентно `[^a-zA-Z0-9_]`.
- `\s`: Любой пробельный символ (пробел, табуляция, перевод строки и т.д.).
- `\S`: Любой символ, кроме пробельного.
- `\b`: Граница слова (позиция между буквенно-цифровым символом и небуквенно-цифровым символом).
- `\B`: Не граница слова.
- `^`: Начало строки.
- `$`: Конец строки.
- `[]`: Набор символов. Например, `[abc]` соответствует 'a', 'b' или 'c'. `[a-z]` соответствует любой строчной букве.
- `[^]`: Отрицание набора символов. Например, `[^abc]` соответствует любому символу, кроме 'a', 'b' или 'c'.
- `|`: ИЛИ. Например, `cat|dog` соответствует 'cat' или 'dog'.
- `()`: Группировка. Используется для создания подвыражений и захвата совпадений.
- `\`: Экранирование. Используется для поиска метасимволов как обычных символов. Например, `\.` соответствует точке.

##### Квантификаторы

Определяют количество повторений предыдущего символа или группы:

- `*`: Ноль или более повторений. Например, `a*` соответствует '', 'a', 'aa', 'aaa' и т.д.
- `+`: Одно или более повторений. Например, `a+` соответствует 'a', 'aa', 'aaa' и т.д.
- `?`: Ноль или одно повторение (опциональный). Например, `colou?r` соответствует 'color' или 'colour'.
- `{n}`: Ровно `n` повторений. Например, `a{3}` соответствует 'aaa'.
- `{n,}`: `n` или более повторений. Например, `a{2,}` соответствует 'aa', 'aaa' и т.д.
- `{n,m}`: От `n` до `m` повторений. Например, `a{1,3}` соответствует 'a', 'aa' или 'aaa'.

По умолчанию квантификаторы являются "жадными" (greedy) — они пытаются захватить максимально возможное количество символов. Добавление `?` после квантификатора делает его "ленивым" (lazy) — он захватывает минимально возможное количество символов. Например, `.*?`

##### Группы и захват

- `()`: Создает группу для захвата. Совпадение внутри группы может быть извлечено отдельно.
- `(?:...)`: Незахватывающая группа. Группирует, но не захватывает совпадение.
- `\n`: Обратная ссылка на `n`-ю захваченную группу.

##### Флаги

Модификаторы, изменяющие поведение регулярного выражения:

- `i` (IGNORECASE): Игнорировать регистр при поиске.
- `g` (GLOBAL в JS): Найти все совпадения, а не только первое.
- `m` (MULTILINE): `^` и `$` соответствуют началу/концу каждой строки, а не только всей входной строки.
- `s` (DOTALL в Python, `s` в JS): `.` соответствует символу новой строки.

---

### Регулярные выражения в Python

В Python регулярные выражения обрабатываются с помощью встроенного модуля `re`.

#### Модуль `re`

Для работы с регулярными выражениями необходимо импортировать модуль `re`:

```python
import re
```

#### Функции модуля `re`

##### `re.search()`

Ищет первое совпадение шаблона в строке. Возвращает объект совпадения (`Match Object`), если найдено, иначе `None`.

```python
import re

text = "Мой телефон 123-456-7890 и еще 987-654-3210."
pattern = r"\d{3}-\d{3}-\d{4}" # Шаблон для телефонного номера

match = re.search(pattern, text)
if match:
    print(f"Найден телефон: {match.group()}") # match.group() возвращает найденную подстроку
    print(f"Начальная позиция: {match.start()}")
    print(f"Конечная позиция: {match.end()}")
    print(f"Диапазон: {match.span()}")
else:
    print("Телефон не найден.")
```

##### `re.match()`

Ищет совпадение шаблона только в **начале** строки. Возвращает объект совпадения, если найдено, иначе `None`.

```python
import re

text1 = "Привет, мир!"
text2 = "Мир, привет!"
pattern = r"Привет"

match1 = re.match(pattern, text1)
match2 = re.match(pattern, text2)

if match1:
    print(f"Найдено в начале text1: {match1.group()}")
else:
    print("Не найдено в начале text1.")

if match2:
    print(f"Найдено в начале text2: {match2.group()}")
else:
    print("Не найдено в начале text2.")
```

##### `re.findall()`

Находит все непересекающиеся совпадения шаблона в строке и возвращает их в виде списка строк. Если шаблон содержит захватывающие группы, возвращает список кортежей.

```python
import re

text = "apple, banana, cherry, date"
pattern = r"\b\w{5}\b" # Слова из 5 букв

all_matches = re.findall(pattern, text)
print(f"Все слова из 5 букв: {all_matches}") # Вывод: ['apple', 'date']

# Пример с группами
text_emails = "user1@example.com, user2@domain.org"
email_pattern = r"(\w+)@(\w+\.\w+)" # Захватываем имя пользователя и домен

all_emails = re.findall(email_pattern, text_emails)
print(f"Найденные email-ы (с группами): {all_emails}")
# Вывод: [('user1', 'example.com'), ('user2', 'domain.org')]
```

##### `re.sub()`

Заменяет все совпадения шаблона в строке на указанную строку замены.

```python
import re

text = "The quick brown fox jumps over the lazy dog."
pattern = r"fox|dog"
replacement = "cat"

new_text = re.sub(pattern, replacement, text)
print(f"Исходный текст: {text}")
print(f"Измененный текст: {new_text}")

# Пример с использованием захваченных групп в замене
text_names = "Имя: Иван Фамилия: Петров"
name_pattern = r"Имя: (\w+) Фамилия: (\w+)"
replacement_format = r"Полное имя: \1 \2" # \1 - первая группа, \2 - вторая

formatted_name = re.sub(name_pattern, replacement_format, text_names)
print(f"Исходные имена: {text_names}")
print(f"Форматированные имена: {formatted_name}")
```

##### `re.compile()`

Компилирует регулярное выражение в объект `RegexObject` для более эффективного использования, если шаблон будет использоваться многократно.

```python
import re

# Компиляция шаблона
phone_regex = re.compile(r"\d{3}-\d{3}-\d{4}")

text1 = "Звоните по номеру 111-222-3333."
text2 = "Мой номер 444-555-6666."

match1 = phone_regex.search(text1)
match2 = phone_regex.search(text2)

if match1:
    print(f"Найден в text1: {match1.group()}")
if match2:
    print(f"Найден в text2: {match2.group()}")
```

#### Объект совпадения (Match Object)

Объект, возвращаемый функциями `re.search()` и `re.match()`, содержит информацию о найденном совпадении:

- `match.group(0)` или `match.group()`: Вся совпавшая подстрока.
- `match.group(N)`: Подстрока, совпавшая с `N`-й захватывающей группой.
- `match.groups()`: Кортеж всех захваченных подстрок.
- `match.start()`: Начальный индекс совпадения.
- `match.end()`: Конечный индекс совпадения (не включая).
- `match.span()`: Кортеж `(start, end)`.

---

### Регулярные выражения в JavaScript

В JavaScript регулярные выражения являются встроенным типом данных (`RegExp`) и могут использоваться с методами строковых объектов.

#### Создание регулярных выражений

1.  **Литерал регулярного выражения**: Самый распространенный способ.
    ```javascript
    const regex1 = /pattern/flags;
    const emailRegex = /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g;
    ```
2.  **Конструктор `RegExp`**: Полезно, когда шаблон или флаги генерируются динамически.

    ```javascript
    const patternString = "\\d{3}-\\d{2}-\\d{4}"; // Двойное экранирование для строк
    const flagsString = "i";
    const regex2 = new RegExp(patternString, flagsString);

    const dynamicWord = "hello";
    const dynamicRegex = new RegExp(dynamicWord, "gi");
    ```

#### Флаги регулярных выражений

Флаги добавляются после закрывающего слэша в литерале или как второй аргумент в конструкторе `RegExp`.

- `i` (ignore case): Игнорировать регистр.
- `g` (global): Найти все совпадения, а не только первое.
- `m` (multiline): `^` и `$` соответствуют началу/концу каждой строки (разделенной `\n`), а не только всей входной строки.
- `s` (dotAll): `.` соответствует символу новой строки.
- `u` (unicode): Обрабатывать шаблон как последовательность кодовых точек Юникода.
- `y` (sticky): Соответствие только с начала текущей позиции в строке.

#### Методы объекта `RegExp`

##### `RegExp.prototype.test()`

Проверяет, есть ли совпадение шаблона в строке. Возвращает `true` или `false`.

```javascript
const phoneNumberRegex = /\d{3}-\d{3}-\d{4}/;

console.log(phoneNumberRegex.test("Мой номер: 123-456-7890")); // true
console.log(phoneNumberRegex.test("Нет номера здесь.")); // false
```

##### `RegExp.prototype.exec()`

Выполняет поиск совпадения в строке. Возвращает массив с информацией о совпадении (включая захваченные группы) или `null`, если совпадений нет. Если используется с флагом `g`, `exec()` будет последовательно находить все совпадения при каждом вызове, обновляя свойство `lastIndex` регулярного выражения.

```javascript
const emailRegex = /(\w+)@(\w+\.\w+)/g; // Флаг 'g' важен для итерации
const text = "email1@example.com, email2@domain.org";

let match;
while ((match = emailRegex.exec(text)) !== null) {
  console.log(`Найден email: ${match[0]}`); // Полное совпадение
  console.log(`Имя пользователя: ${match[1]}`); // Первая захваченная группа
  console.log(`Домен: ${match[2]}`); // Вторая захваченная группа
  console.log(`Индекс совпадения: ${match.index}`);
  console.log(`Следующий поиск начнется с индекса: ${emailRegex.lastIndex}`);
  console.log("---");
}
```

**Предполагаемый вывод:**

```
Найден email: email1@example.com
Имя пользователя: email1
Домен: example.com
Индекс совпадения: 0
Следующий поиск начнется с индекса: 18
---
Найден email: email2@domain.org
Имя пользователя: email2
Домен: domain.org
Индекс совпадения: 20
Следующий поиск начнется с индекса: 37
---
```

#### Методы строковых объектов

##### `String.prototype.match()`

Ищет совпадения в строке.

- Если регулярное выражение **без флага `g`**: Возвращает такой же массив, как `RegExp.prototype.exec()`, или `null`.
- Если регулярное выражение **с флагом `g`**: Возвращает массив всех совпадений в виде строк, или `null`. Захваченные группы не возвращаются.

```javascript
const text = "The cat sat on the mat.";
const regexNoG = /at/;
const regexWithG = /at/g;

console.log(text.match(regexNoG));
// Вывод: ["at", index: 5, input: "The cat sat on the mat.", groups: undefined]

console.log(text.match(regexWithG));
// Вывод: ["at", "at", "at"]
```

##### `String.prototype.search()`

Ищет первое совпадение шаблона в строке и возвращает индекс начальной позиции совпадения. Возвращает `-1`, если совпадений нет.

```javascript
const text = "Hello world!";
console.log(text.search(/world/)); // 6
console.log(text.search(/foo/)); // -1
```

##### `String.prototype.replace()`

Заменяет совпадения шаблона на указанную строку или результат функции.

```javascript
const text = "I like apples and oranges. Apples are good.";
const regex = /apples/g;
const newText = text.replace(regex, "bananas");
console.log(newText); // I like bananas and oranges. Bananas are good.

// Использование функции для замены
const names = "John Doe, Jane Smith";
const nameRegex = /(\w+)\s(\w+)/g; // Захватываем имя и фамилию

const formattedNames = names.replace(
  nameRegex,
  (match, firstName, lastName) => {
    return `${lastName.toUpperCase()}, ${firstName}`;
  }
);
console.log(formattedNames); // DOE, John, SMITH, Jane
```

##### `String.prototype.split()`

Разделяет строку на массив подстрок, используя регулярное выражение (или строку) в качестве разделителя.

```javascript
const csvString = "apple,banana,cherry";
const words = csvString.split(/,/);
console.log(words); // ["apple", "banana", "cherry"]

const sentence = "One two   three. Four!";
const parts = sentence.split(/\s+/); // Разделяем по одному или более пробелам
console.log(parts); // ["One", "two", "three.", "Four!"]
```
